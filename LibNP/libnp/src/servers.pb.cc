// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: servers.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "servers.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_servers_2eproto() {
  delete SessionData::default_instance_;
  delete SessionInfo::default_instance_;
  delete ServersCreateSessionMessage::default_instance_;
  delete ServersCreateSessionResultMessage::default_instance_;
  delete ServersGetSessionsMessage::default_instance_;
  delete ServersGetSessionsResultMessage::default_instance_;
  delete ServersUpdateSessionMessage::default_instance_;
  delete ServersUpdateSessionResultMessage::default_instance_;
  delete ServersDeleteSessionMessage::default_instance_;
  delete ServersDeleteSessionResultMessage::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_servers_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_servers_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  SessionData::default_instance_ = new SessionData();
  SessionInfo::default_instance_ = new SessionInfo();
  ServersCreateSessionMessage::default_instance_ = new ServersCreateSessionMessage();
  ServersCreateSessionResultMessage::default_instance_ = new ServersCreateSessionResultMessage();
  ServersGetSessionsMessage::default_instance_ = new ServersGetSessionsMessage();
  ServersGetSessionsResultMessage::default_instance_ = new ServersGetSessionsResultMessage();
  ServersUpdateSessionMessage::default_instance_ = new ServersUpdateSessionMessage();
  ServersUpdateSessionResultMessage::default_instance_ = new ServersUpdateSessionResultMessage();
  ServersDeleteSessionMessage::default_instance_ = new ServersDeleteSessionMessage();
  ServersDeleteSessionResultMessage::default_instance_ = new ServersDeleteSessionResultMessage();
  SessionData::default_instance_->InitAsDefaultInstance();
  SessionInfo::default_instance_->InitAsDefaultInstance();
  ServersCreateSessionMessage::default_instance_->InitAsDefaultInstance();
  ServersCreateSessionResultMessage::default_instance_->InitAsDefaultInstance();
  ServersGetSessionsMessage::default_instance_->InitAsDefaultInstance();
  ServersGetSessionsResultMessage::default_instance_->InitAsDefaultInstance();
  ServersUpdateSessionMessage::default_instance_->InitAsDefaultInstance();
  ServersUpdateSessionResultMessage::default_instance_->InitAsDefaultInstance();
  ServersDeleteSessionMessage::default_instance_->InitAsDefaultInstance();
  ServersDeleteSessionResultMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_servers_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_servers_2eproto_once_);
void protobuf_AddDesc_servers_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_servers_2eproto_once_,
                 &protobuf_AddDesc_servers_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_servers_2eproto {
  StaticDescriptorInitializer_servers_2eproto() {
    protobuf_AddDesc_servers_2eproto();
  }
} static_descriptor_initializer_servers_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int SessionData::kKeyFieldNumber;
const int SessionData::kValueFieldNumber;
#endif  // !_MSC_VER

SessionData::SessionData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SessionData::InitAsDefaultInstance() {
}

SessionData::SessionData(const SessionData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SessionData::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionData::~SessionData() {
  SharedDtor();
}

void SessionData::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SessionData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionData& SessionData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

SessionData* SessionData::default_instance_ = NULL;

SessionData* SessionData::New() const {
  return new SessionData;
}

void SessionData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SessionData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }

}

int SessionData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SessionData*>(&from));
}

void SessionData::MergeFrom(const SessionData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void SessionData::CopyFrom(const SessionData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SessionData::Swap(SessionData* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SessionData::GetTypeName() const {
  return "SessionData";
}


// ===================================================================

#ifndef _MSC_VER
const int SessionInfo::kAddressFieldNumber;
const int SessionInfo::kPortFieldNumber;
const int SessionInfo::kNpidFieldNumber;
const int SessionInfo::kPlayersFieldNumber;
const int SessionInfo::kMaxplayersFieldNumber;
const int SessionInfo::kDataFieldNumber;
const int SessionInfo::kSidFieldNumber;
#endif  // !_MSC_VER

SessionInfo::SessionInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SessionInfo::InitAsDefaultInstance() {
}

SessionInfo::SessionInfo(const SessionInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SessionInfo::SharedCtor() {
  _cached_size_ = 0;
  address_ = 0u;
  port_ = 0;
  npid_ = GOOGLE_ULONGLONG(0);
  players_ = 0;
  maxplayers_ = 0;
  sid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionInfo::~SessionInfo() {
  SharedDtor();
}

void SessionInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SessionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionInfo& SessionInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

SessionInfo* SessionInfo::default_instance_ = NULL;

SessionInfo* SessionInfo::New() const {
  return new SessionInfo;
}

void SessionInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    address_ = 0u;
    port_ = 0;
    npid_ = GOOGLE_ULONGLONG(0);
    players_ = 0;
    maxplayers_ = 0;
    sid_ = GOOGLE_ULONGLONG(0);
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SessionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &address_)));
          set_has_address();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // optional int32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_npid;
        break;
      }

      // optional fixed64 npid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_npid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &npid_)));
          set_has_npid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_players;
        break;
      }

      // optional int32 players = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_players:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &players_)));
          set_has_players();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_maxplayers;
        break;
      }

      // optional int32 maxplayers = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxplayers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxplayers_)));
          set_has_maxplayers();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_data;
        break;
      }

      // repeated .SessionData data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_data;
        if (input->ExpectTag(56)) goto parse_sid;
        break;
      }

      // optional uint64 sid = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->address(), output);
  }

  // optional int32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }

  // optional fixed64 npid = 3;
  if (has_npid()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(3, this->npid(), output);
  }

  // optional int32 players = 4;
  if (has_players()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->players(), output);
  }

  // optional int32 maxplayers = 5;
  if (has_maxplayers()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->maxplayers(), output);
  }

  // repeated .SessionData data = 6;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->data(i), output);
  }

  // optional uint64 sid = 7;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->sid(), output);
  }

}

int SessionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->address());
    }

    // optional int32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

    // optional fixed64 npid = 3;
    if (has_npid()) {
      total_size += 1 + 8;
    }

    // optional int32 players = 4;
    if (has_players()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->players());
    }

    // optional int32 maxplayers = 5;
    if (has_maxplayers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxplayers());
    }

    // optional uint64 sid = 7;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sid());
    }

  }
  // repeated .SessionData data = 6;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SessionInfo*>(&from));
}

void SessionInfo::MergeFrom(const SessionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_npid()) {
      set_npid(from.npid());
    }
    if (from.has_players()) {
      set_players(from.players());
    }
    if (from.has_maxplayers()) {
      set_maxplayers(from.maxplayers());
    }
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
}

void SessionInfo::CopyFrom(const SessionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionInfo::IsInitialized() const {

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void SessionInfo::Swap(SessionInfo* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(port_, other->port_);
    std::swap(npid_, other->npid_);
    std::swap(players_, other->players_);
    std::swap(maxplayers_, other->maxplayers_);
    data_.Swap(&other->data_);
    std::swap(sid_, other->sid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SessionInfo::GetTypeName() const {
  return "SessionInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersCreateSessionMessage::kInfoFieldNumber;
#endif  // !_MSC_VER

ServersCreateSessionMessage::ServersCreateSessionMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersCreateSessionMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::SessionInfo*>(
      ::SessionInfo::internal_default_instance());
#else
  info_ = const_cast< ::SessionInfo*>(&::SessionInfo::default_instance());
#endif
}

ServersCreateSessionMessage::ServersCreateSessionMessage(const ServersCreateSessionMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersCreateSessionMessage::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersCreateSessionMessage::~ServersCreateSessionMessage() {
  SharedDtor();
}

void ServersCreateSessionMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void ServersCreateSessionMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersCreateSessionMessage& ServersCreateSessionMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersCreateSessionMessage* ServersCreateSessionMessage::default_instance_ = NULL;

ServersCreateSessionMessage* ServersCreateSessionMessage::New() const {
  return new ServersCreateSessionMessage;
}

void ServersCreateSessionMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::SessionInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersCreateSessionMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SessionInfo info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersCreateSessionMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .SessionInfo info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->info(), output);
  }

}

int ServersCreateSessionMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .SessionInfo info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersCreateSessionMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersCreateSessionMessage*>(&from));
}

void ServersCreateSessionMessage::MergeFrom(const ServersCreateSessionMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::SessionInfo::MergeFrom(from.info());
    }
  }
}

void ServersCreateSessionMessage::CopyFrom(const ServersCreateSessionMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersCreateSessionMessage::IsInitialized() const {

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void ServersCreateSessionMessage::Swap(ServersCreateSessionMessage* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersCreateSessionMessage::GetTypeName() const {
  return "ServersCreateSessionMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersCreateSessionResultMessage::kResultFieldNumber;
const int ServersCreateSessionResultMessage::kSessionidFieldNumber;
#endif  // !_MSC_VER

ServersCreateSessionResultMessage::ServersCreateSessionResultMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersCreateSessionResultMessage::InitAsDefaultInstance() {
}

ServersCreateSessionResultMessage::ServersCreateSessionResultMessage(const ServersCreateSessionResultMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersCreateSessionResultMessage::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  sessionid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersCreateSessionResultMessage::~ServersCreateSessionResultMessage() {
  SharedDtor();
}

void ServersCreateSessionResultMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServersCreateSessionResultMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersCreateSessionResultMessage& ServersCreateSessionResultMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersCreateSessionResultMessage* ServersCreateSessionResultMessage::default_instance_ = NULL;

ServersCreateSessionResultMessage* ServersCreateSessionResultMessage::New() const {
  return new ServersCreateSessionResultMessage;
}

void ServersCreateSessionResultMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    sessionid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersCreateSessionResultMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_sessionid;
        break;
      }

      // optional fixed64 sessionid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_sessionid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &sessionid_)));
          set_has_sessionid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersCreateSessionResultMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional fixed64 sessionid = 2;
  if (has_sessionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(2, this->sessionid(), output);
  }

}

int ServersCreateSessionResultMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional fixed64 sessionid = 2;
    if (has_sessionid()) {
      total_size += 1 + 8;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersCreateSessionResultMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersCreateSessionResultMessage*>(&from));
}

void ServersCreateSessionResultMessage::MergeFrom(const ServersCreateSessionResultMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_sessionid()) {
      set_sessionid(from.sessionid());
    }
  }
}

void ServersCreateSessionResultMessage::CopyFrom(const ServersCreateSessionResultMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersCreateSessionResultMessage::IsInitialized() const {

  return true;
}

void ServersCreateSessionResultMessage::Swap(ServersCreateSessionResultMessage* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(sessionid_, other->sessionid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersCreateSessionResultMessage::GetTypeName() const {
  return "ServersCreateSessionResultMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersGetSessionsMessage::kInfosFieldNumber;
#endif  // !_MSC_VER

ServersGetSessionsMessage::ServersGetSessionsMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersGetSessionsMessage::InitAsDefaultInstance() {
}

ServersGetSessionsMessage::ServersGetSessionsMessage(const ServersGetSessionsMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersGetSessionsMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersGetSessionsMessage::~ServersGetSessionsMessage() {
  SharedDtor();
}

void ServersGetSessionsMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServersGetSessionsMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersGetSessionsMessage& ServersGetSessionsMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersGetSessionsMessage* ServersGetSessionsMessage::default_instance_ = NULL;

ServersGetSessionsMessage* ServersGetSessionsMessage::New() const {
  return new ServersGetSessionsMessage;
}

void ServersGetSessionsMessage::Clear() {
  infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersGetSessionsMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .SessionData infos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_infos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_infos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersGetSessionsMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .SessionData infos = 1;
  for (int i = 0; i < this->infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->infos(i), output);
  }

}

int ServersGetSessionsMessage::ByteSize() const {
  int total_size = 0;

  // repeated .SessionData infos = 1;
  total_size += 1 * this->infos_size();
  for (int i = 0; i < this->infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->infos(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersGetSessionsMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersGetSessionsMessage*>(&from));
}

void ServersGetSessionsMessage::MergeFrom(const ServersGetSessionsMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  infos_.MergeFrom(from.infos_);
}

void ServersGetSessionsMessage::CopyFrom(const ServersGetSessionsMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersGetSessionsMessage::IsInitialized() const {

  for (int i = 0; i < infos_size(); i++) {
    if (!this->infos(i).IsInitialized()) return false;
  }
  return true;
}

void ServersGetSessionsMessage::Swap(ServersGetSessionsMessage* other) {
  if (other != this) {
    infos_.Swap(&other->infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersGetSessionsMessage::GetTypeName() const {
  return "ServersGetSessionsMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersGetSessionsResultMessage::kServersFieldNumber;
#endif  // !_MSC_VER

ServersGetSessionsResultMessage::ServersGetSessionsResultMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersGetSessionsResultMessage::InitAsDefaultInstance() {
}

ServersGetSessionsResultMessage::ServersGetSessionsResultMessage(const ServersGetSessionsResultMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersGetSessionsResultMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersGetSessionsResultMessage::~ServersGetSessionsResultMessage() {
  SharedDtor();
}

void ServersGetSessionsResultMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServersGetSessionsResultMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersGetSessionsResultMessage& ServersGetSessionsResultMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersGetSessionsResultMessage* ServersGetSessionsResultMessage::default_instance_ = NULL;

ServersGetSessionsResultMessage* ServersGetSessionsResultMessage::New() const {
  return new ServersGetSessionsResultMessage;
}

void ServersGetSessionsResultMessage::Clear() {
  servers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersGetSessionsResultMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .SessionInfo servers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_servers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_servers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_servers;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersGetSessionsResultMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .SessionInfo servers = 1;
  for (int i = 0; i < this->servers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->servers(i), output);
  }

}

int ServersGetSessionsResultMessage::ByteSize() const {
  int total_size = 0;

  // repeated .SessionInfo servers = 1;
  total_size += 1 * this->servers_size();
  for (int i = 0; i < this->servers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->servers(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersGetSessionsResultMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersGetSessionsResultMessage*>(&from));
}

void ServersGetSessionsResultMessage::MergeFrom(const ServersGetSessionsResultMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  servers_.MergeFrom(from.servers_);
}

void ServersGetSessionsResultMessage::CopyFrom(const ServersGetSessionsResultMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersGetSessionsResultMessage::IsInitialized() const {

  for (int i = 0; i < servers_size(); i++) {
    if (!this->servers(i).IsInitialized()) return false;
  }
  return true;
}

void ServersGetSessionsResultMessage::Swap(ServersGetSessionsResultMessage* other) {
  if (other != this) {
    servers_.Swap(&other->servers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersGetSessionsResultMessage::GetTypeName() const {
  return "ServersGetSessionsResultMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersUpdateSessionMessage::kSessionidFieldNumber;
const int ServersUpdateSessionMessage::kInfoFieldNumber;
#endif  // !_MSC_VER

ServersUpdateSessionMessage::ServersUpdateSessionMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersUpdateSessionMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::SessionInfo*>(
      ::SessionInfo::internal_default_instance());
#else
  info_ = const_cast< ::SessionInfo*>(&::SessionInfo::default_instance());
#endif
}

ServersUpdateSessionMessage::ServersUpdateSessionMessage(const ServersUpdateSessionMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersUpdateSessionMessage::SharedCtor() {
  _cached_size_ = 0;
  sessionid_ = GOOGLE_ULONGLONG(0);
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersUpdateSessionMessage::~ServersUpdateSessionMessage() {
  SharedDtor();
}

void ServersUpdateSessionMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void ServersUpdateSessionMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersUpdateSessionMessage& ServersUpdateSessionMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersUpdateSessionMessage* ServersUpdateSessionMessage::default_instance_ = NULL;

ServersUpdateSessionMessage* ServersUpdateSessionMessage::New() const {
  return new ServersUpdateSessionMessage;
}

void ServersUpdateSessionMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sessionid_ = GOOGLE_ULONGLONG(0);
    if (has_info()) {
      if (info_ != NULL) info_->::SessionInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersUpdateSessionMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 sessionid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &sessionid_)));
          set_has_sessionid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // optional .SessionInfo info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersUpdateSessionMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional fixed64 sessionid = 1;
  if (has_sessionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->sessionid(), output);
  }

  // optional .SessionInfo info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->info(), output);
  }

}

int ServersUpdateSessionMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional fixed64 sessionid = 1;
    if (has_sessionid()) {
      total_size += 1 + 8;
    }

    // optional .SessionInfo info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersUpdateSessionMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersUpdateSessionMessage*>(&from));
}

void ServersUpdateSessionMessage::MergeFrom(const ServersUpdateSessionMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sessionid()) {
      set_sessionid(from.sessionid());
    }
    if (from.has_info()) {
      mutable_info()->::SessionInfo::MergeFrom(from.info());
    }
  }
}

void ServersUpdateSessionMessage::CopyFrom(const ServersUpdateSessionMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersUpdateSessionMessage::IsInitialized() const {

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void ServersUpdateSessionMessage::Swap(ServersUpdateSessionMessage* other) {
  if (other != this) {
    std::swap(sessionid_, other->sessionid_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersUpdateSessionMessage::GetTypeName() const {
  return "ServersUpdateSessionMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersUpdateSessionResultMessage::kResultFieldNumber;
#endif  // !_MSC_VER

ServersUpdateSessionResultMessage::ServersUpdateSessionResultMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersUpdateSessionResultMessage::InitAsDefaultInstance() {
}

ServersUpdateSessionResultMessage::ServersUpdateSessionResultMessage(const ServersUpdateSessionResultMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersUpdateSessionResultMessage::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersUpdateSessionResultMessage::~ServersUpdateSessionResultMessage() {
  SharedDtor();
}

void ServersUpdateSessionResultMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServersUpdateSessionResultMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersUpdateSessionResultMessage& ServersUpdateSessionResultMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersUpdateSessionResultMessage* ServersUpdateSessionResultMessage::default_instance_ = NULL;

ServersUpdateSessionResultMessage* ServersUpdateSessionResultMessage::New() const {
  return new ServersUpdateSessionResultMessage;
}

void ServersUpdateSessionResultMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersUpdateSessionResultMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersUpdateSessionResultMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ServersUpdateSessionResultMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersUpdateSessionResultMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersUpdateSessionResultMessage*>(&from));
}

void ServersUpdateSessionResultMessage::MergeFrom(const ServersUpdateSessionResultMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ServersUpdateSessionResultMessage::CopyFrom(const ServersUpdateSessionResultMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersUpdateSessionResultMessage::IsInitialized() const {

  return true;
}

void ServersUpdateSessionResultMessage::Swap(ServersUpdateSessionResultMessage* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersUpdateSessionResultMessage::GetTypeName() const {
  return "ServersUpdateSessionResultMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersDeleteSessionMessage::kSessionidFieldNumber;
#endif  // !_MSC_VER

ServersDeleteSessionMessage::ServersDeleteSessionMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersDeleteSessionMessage::InitAsDefaultInstance() {
}

ServersDeleteSessionMessage::ServersDeleteSessionMessage(const ServersDeleteSessionMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersDeleteSessionMessage::SharedCtor() {
  _cached_size_ = 0;
  sessionid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersDeleteSessionMessage::~ServersDeleteSessionMessage() {
  SharedDtor();
}

void ServersDeleteSessionMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServersDeleteSessionMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersDeleteSessionMessage& ServersDeleteSessionMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersDeleteSessionMessage* ServersDeleteSessionMessage::default_instance_ = NULL;

ServersDeleteSessionMessage* ServersDeleteSessionMessage::New() const {
  return new ServersDeleteSessionMessage;
}

void ServersDeleteSessionMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sessionid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersDeleteSessionMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 sessionid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &sessionid_)));
          set_has_sessionid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersDeleteSessionMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional fixed64 sessionid = 1;
  if (has_sessionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->sessionid(), output);
  }

}

int ServersDeleteSessionMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional fixed64 sessionid = 1;
    if (has_sessionid()) {
      total_size += 1 + 8;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersDeleteSessionMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersDeleteSessionMessage*>(&from));
}

void ServersDeleteSessionMessage::MergeFrom(const ServersDeleteSessionMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sessionid()) {
      set_sessionid(from.sessionid());
    }
  }
}

void ServersDeleteSessionMessage::CopyFrom(const ServersDeleteSessionMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersDeleteSessionMessage::IsInitialized() const {

  return true;
}

void ServersDeleteSessionMessage::Swap(ServersDeleteSessionMessage* other) {
  if (other != this) {
    std::swap(sessionid_, other->sessionid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersDeleteSessionMessage::GetTypeName() const {
  return "ServersDeleteSessionMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServersDeleteSessionResultMessage::kResultFieldNumber;
#endif  // !_MSC_VER

ServersDeleteSessionResultMessage::ServersDeleteSessionResultMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServersDeleteSessionResultMessage::InitAsDefaultInstance() {
}

ServersDeleteSessionResultMessage::ServersDeleteSessionResultMessage(const ServersDeleteSessionResultMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServersDeleteSessionResultMessage::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServersDeleteSessionResultMessage::~ServersDeleteSessionResultMessage() {
  SharedDtor();
}

void ServersDeleteSessionResultMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServersDeleteSessionResultMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServersDeleteSessionResultMessage& ServersDeleteSessionResultMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_servers_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_servers_2eproto();
#endif
  return *default_instance_;
}

ServersDeleteSessionResultMessage* ServersDeleteSessionResultMessage::default_instance_ = NULL;

ServersDeleteSessionResultMessage* ServersDeleteSessionResultMessage::New() const {
  return new ServersDeleteSessionResultMessage;
}

void ServersDeleteSessionResultMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServersDeleteSessionResultMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServersDeleteSessionResultMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ServersDeleteSessionResultMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServersDeleteSessionResultMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServersDeleteSessionResultMessage*>(&from));
}

void ServersDeleteSessionResultMessage::MergeFrom(const ServersDeleteSessionResultMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ServersDeleteSessionResultMessage::CopyFrom(const ServersDeleteSessionResultMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServersDeleteSessionResultMessage::IsInitialized() const {

  return true;
}

void ServersDeleteSessionResultMessage::Swap(ServersDeleteSessionResultMessage* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServersDeleteSessionResultMessage::GetTypeName() const {
  return "ServersDeleteSessionResultMessage";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
